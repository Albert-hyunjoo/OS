# 프로세스의 관리

## 프로세스와 프로그램
* `프로그램`은 하드 디스크 안에 저장된 일련의 코드 묶음이다.
* `프로세스`는 HDD에서 `OS` 부팅 후에 `메인 메모리`로 올라간 **실행 중인** 프로그램이다.

## 프로세스의 상태에 대해
* 프로세스의 상태는 크게 `NEW`, `READY`, `RUNNING`, `WAITING`, `TERMINATE`
* `RUNNING`을 하고 있다가 `I/O Interruption`이 들어오면 `WAITING` 상태이다.
* `WAITING`이 끝나면 다시 `ready` 상태가 되어서 `CPU` 의 프로세스 배정을 기대한다.
* 만약 프로세스 실행에 **시간 제한**이 존재하면, `RUNNING`에서 `READY`로 바로 넘어가는 커맨드가 있다.

## PCB에 대해서

* `PCB`는 **프로세스를 컨트롤하는 블럭**이다.
* `PCB`는 한 프로세스 당 **하나**씩 배정이 된다.
* `PCB`는 `OS`의 프로세스 파트에 있으며, 다음 요소를 포함한다.
    1) 프로세스 식별자 : 프로세스의 고유 ID
    2) 프로세스의 상태
    3) 프로그램 계수기 (Counter) : 다음에 실행할 명령어의 주소
    4) cpu 스케쥴링의 정보
    5) 메모리 관리 정보
    6) 프로세스 계정 정보
    7) CPU 사용기록
    8) 프로세스가 사용 중인 파일
    
## Queue (큐 – 대기열)

* `I/O` 요청이나 `Main Memory` 프로세스 요청 등은 모두 `스케쥴러` 의해 순서가 정해진다.
* `queue`에는 3가지 종류가 존재한다.
    * `Job Queue` -- **JOB 스케쥴러**
        * `long-term schedule`로 **어떤 프로세스를 실행**할지 신중하게 수행한다.
        * 여기서 쓰인 `Long-term scheduler`는 `하드 디스크`에서 `메모리`로 프로레스 `load`
            * *다중 프로그래밍의 수준 (degree) 를 제어한다*
            * `new` 상태를 `ready`로 전환한다.
            * *왜 long?* 메모리가 빌 때만 활성화되므로 굳이 많이 할 필요 X
    * `Ready Queue` -- **CPU 스케쥴러**
        * `ready` 상태의 프로세스가 CPU를 할당받을 때까지 기다리는 곳
        * 이는 `short-term schedule`로 시행된다; `Ready Queue` 중 뭐를 먼저 `running`?
            - *바로바로 하는 이유는? `CPU`의 효율성을 위해서!*
    * `Device Queue` -- **DEVICE 스케쥴러**
        * `I/O` 등의 요청을 처리하는 순서를 모아놓은 구조
        * `Device Scheduler`를 사용해서 우선순위를 처리한다.
    
## I/O Bound와 CPU Bound

* 대부분의 프로세스 실행 순서는 `I/O`와 `CPU`의 바운드 (작업량)로 결정된다.
* CPU 스케쥴링을 실시할 때의 우선순위는 **CPU의 사용량**이다.
    * `CPU Bound`는 수행하는 (복잡한) 컴퓨팅 작업이 CPU의 속도에 따라 결정 (긴 버스트)
    * `I/O Bound`는 I/O가 시작하고 끝나는 시간에 의해 결정 (짧은 버스트)
        * _데이터가 load/unload되는 동안 CPU는 기다려야 하므로 컴퓨터의 속도가 감소_
    * 일반적으로 `I/O Bound`가 우선시되는데, 이는 **CPU의 사용시간이 짧기 때문이다**
    
## Mid-term Scheduler

* 프로세스가 **무응답이나 기타 오류** 상황으로 인해 state 변화 없이 유지되면, 메모리만 차지한다.
* `mid-term scheduler`는 이러한 프로세스를 쫓아내거나 (`Swap-out`) 다시 들어오게 할 수 있다 (`swap-in`)
* 단, `swap-in`된 프로세스는 다시 Queue를 기다려야 한다.
