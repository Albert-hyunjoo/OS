# CPU 스케쥴링 (3)

## Multilevel Queue Scheduling
* 원래는 **Single Ready Queue**를 통해 CPU로 처리를 하지만, 다양한 **Process Group**에 맞춰서    
다양한 level을 통해서 프로세스를 배열 및 스케쥴링을 하는 방식
* 프로세스 그룹은 **다음과 같은 종류**가 존재한다.
    * System Process : OS 등의 **중요한 프로세스**의 모음
    * Interactive Process : 게임 등과 같이 사용자의 **입력**과 **지속적인 상호 작용**
    * Interactive Editing Process : *워드프로세서* 같이 **지속적으로 편집**을 하는 프로세스
    * Batch Process : 컴퓨터가 **뒤에서 알아서** 하는 프로세스 (대화형이 아니며 **일괄 처리로**)
    * Student Processes : 학생이 만든 프로그램을 통해 행하는 프로세스
* 각각의 Queue에는 **절대적 우선순위**가 존재하며, 이는 다른 **Queue**에 영향을 끼치지 않는 **독립**이다.
* 전체적인 CPU 타임을 각 Queue에 **차등배분하는 형식**으로도 진행할 수 있다.

## Multilevel *Feedback* Queue Scheduling
* `MQS`같이 복수 개의 Queue가 돌아가지만, 만약 필요시에는 다른 Queue로 넘어간다.
* 보통 다른 Queue로 넘어가는 이유는 *지나친 CPU Time 사용*이나, *기아 상태가 우려되는 경우*다.
* 다양한 OS에서는 이러한 CPU 스케쥴링 방법의 대부분을 혼용하고 있다.

## 프로세스의 생성 및 종료
* ` (자식) 프로세스`는 통상적으로 `(부모) 프로세스`에 의해 만들어지는 경우가 많다.
* 이러한 프로세스는 OS가 부팅될 때 처음 생겨나고, (init) 트리 형식으로 자식 프로세스가 생성된다.
* 프로세스에는 *주민등록번호* 개념의 `PID`가 존재하며, 프로세스는 0부터 시작한다.
* 프로세스 생성은 `fork()`라는 명령어에 따라 부모 프로세스를 복사, `exec()`는 실행파일의 메모리 배치이다.
* 프로세스가 생성되면 `프로세스 블록` 안에는 식별자, 우선순위, 할당 자원, 자원 목록 등의 정보가 기록되고 준비 상태에서 Ready
> **[개괄적인 프로세스의 생성 과정]**    
> 1) 새로운 프로세스에 프로세스 식별자 (PID) 할당
> 2) 프로세스의 구성 요소를 포함하는 주소 공간과 제어 블록 공간을 할당
> 3) 프로세스 제어 블록을 초기화한다 (카운터, 정보, 스택 포인터, 자원, 우선순위)
> 4) 해당 큐에 삽입한다.

* 부모 프로세스는 자식 프로세스에 자원을 나눠주거나 일부 자원 및 초기화 데이터를 공유할 수 있다.
* `fork()`를 실행하면 `부모 프로세스`에서는 `자식 프로세스`를, `자식 프로세스`는 0을 return한다.
* 프로세스의 종료는 `exit()` 시스템 콜을 통해서 행하며, 프로세스가 가졌던 모든 자원은 `OS`에 반환한다.