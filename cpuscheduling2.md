# CPU 스케쥴링 (2)

## Shortest-Job-First (SJF) -- Non Preemptive
* 가장 `빨리 걸리는 프로세스`부터 먼저 처리하는 형태로 진행
* 대부분의 상황에서 효율적이지만, 보통 `비현실적인` 방법으로 취급됨
* 주기적으로 프로세스가 순회하는 과정에서 CPU가 `burst time`을 `estimate` 해야!

|프로세스|Burst Time|실행 순서|대기 시간|
|:---:|:---:|:---:|:---:|
|P1|6|2|3|
|P2|8|4|9|
|P3|7|3|16|
|P4|3|1|0|
|**Average Waiting Time**|*7m/sec* `(0+3+9+16)/4`

## Shortest-Remaining-Time-First (SRTF) -- Preemptive
* `SJF`의 침습 형식으로, 잔여 시간을 계산해서 `가장 짧은 잔여 시간`부터 스타트
* 중간에 실행 중인 프로세스를 방해하고 난입할 수 있다.

|프로세스|도착 시간|실행 시간|
|:---:|:---:|:---:|
|P1|0|8|
|P2|2|4|
|P3|3|2|
|P4|5|1|
|P5|9|8|

## Priority Scheduling
* 각 프로세스에 `우선 순위 (priority)`를 부여해서 그대로 처리한다.
* `우선순위`를 배정하는 기준은 다양하다 (시간 제한, 메모리 제한, 정치적 요인, 유료 계정..)
* `기아`는 `프로세스`의 `우선순위`가 너무 낮아서 **원하는 자원을 할당받지 못하는 경우**     
보통 이 경우에는 `aging`으로 **시간이 지날수록 `우선순위`를 높이는 방법**으로 해결한다.
  
## RR (Round-Robin)
* `Round-robin` 방식은 특정한 `Time Quantum`에 따라 슬라이스를 하는 경우
* `preemptive`한 스케쥴링 방식에 해당하며, `Time Quantum`이 끝나면 바로 전환!
* 만약 `Time Quantum`이 **무한대**면 `FCFS`, **0초**면 빈번한 `Process Sharing`에 따른 `CWO` 발생


